## `Q1`
For our Tree, before assigning a node to a index we will have to initialise that node using TreeNode Class. Then we have addRight() and addLeft() method in tree class where if we have to assign a node in a tree we have to specify the parent node as well as the node to be assigned. With the use of a parent node our tree implementation becomes very seamless. Within the addLeft() and addRight() method in Tree class it calls another addLeft() and addRight() method in TreeNode class which adds a node to whatever side we called it for that particular parent. With help of a parent node we can easily traverse up the tree. I have tried to make the all classes as generic as possible. I have also implemented Linked List and a Stack as Data structures. I reffered to my CS 142 class's code while implementing the Linked List. For the Stack i reffered to our old in class coding excersise where professor Bose made us implement Stack and Queue in class.

#### `toString();`
For the toString() method, one way to approach this problem is printing the tree generation by generation from one direction to the other. But in this case There's a issue with special type of trees, like for a skewed right tree the code will have to iterate through all the null nodes in the generation coming before that right most node. So, a better way to approach this problem is to visit every node only once such that they are also printed at the same time. For, this idea the best way was to use any of the tree travesals methods from InOrder, Pre-Order, Post-Order. I here choose to use a Pre-Order Traversal but any would have just worked fine.

#### (i) `depth();`
This is a recursive method called `depth()`, which takes a type generic TreeNode node as an `argument` and returns an integer value representing the depth of the node in the tree. First, it checks if the `given node has no left or right children`. If this is the case, the node is a root node, and its depth is 1. In this case, the method `returns 1`. Then it checks if the node has `a left child but no right child`, the method adds 1 to the depth of the left child and calls itself recursively on the next left child. The method then `returns the result of the recursive call`. Then it checks if the node has `a right child but no left child`, the method adds 1 to the depth of the right child and calls itself recursively on the right child. The method then `returns the result of the recursive call`. Then it checks if the node has both left and right children, the method recursively calls itself on both the left and right children, adding 1 to the depth of each child. The method then `returns the maximum of the two recursive calls`. If `none of the above conditions are met`, the method `returns -1`. However, since this should never happen and hence, the `code should never gets to this`. The time complexity of the given code is `O(n)`, where n is the number of nodes in the tree. This is because the code traverses the tree recursively, visiting each node once.

#### (ii) `pathToRoot();`
This is a method named `pathToRoot()`, which takes a TreeNode<T> node as a `argument` and returns a `OurLinkedList<T> object` representing the path from the given node to the root of a tree. Firstly it creates an `empty linked list` called `path` of type `OurLinkedList<T>`. Then there is a `while loop` that continues until the `getParent() method` returns `null`, which indicates that the current node is the root node. Inside the while loop, `adds the value of the current node` to the beginning of the Linked list using the `addFront() method` and then it `updates the value of node to the parent of the current node` using the `getParent() method`, so the next iteration of the loop will process the parent node. After the while loop ends, adds the value of the root node to the beginning of the path list. `Returns the path linked list` containing all the values from the given node to the root node. The time complexity of this code is `O(h)`, where h is the `height of the tree`. This is because the while loop iterates from the `given node to its parent until the root node` is reached, and the height of the tree determines the maximum number of iterations needed to reach the root.

 #### (iii) `siblings();`
This method `returns the values of the siblings` of a given node in the tree. The method takes in a `TreeNode<T> node` as a argument, which represents the node whose siblings are to be found. The method then `returns a linked list` of values representing the siblings of the given node. The function first creates a `new empty linked list` to store the values of the siblings. If the given node is the `root of the tree, there are no siblings`, and hence the method `adds a null` value to the linked list and `returns it` (This is th3e base case). Else wise, the function `moves up one generation` in the tree to get the parent node using the `getParent() method`. It then gets the values of the left and right child nodes of the parent node using the `getLeft()` and `getRight()` methods, and then `adds` it to the linked list using a `add() method`. The time complexity of this method is `O(1)`, as the time it takes to execute does not depend on the size of the tree. This is because the code only performs a constant number of operations to find the siblings of a given node. The space complexity of this code is also `O(1)`, because it uses a constant amount of memory to store the linked list.

 #### (iv) `LeastCommonSubsume();`
This method takes two `TreeNode<T> node` (node1 and node2) as `argument` and returns the `deepest node` that is a `parent to both of them`. The method `first compares` if both the nodes are from `same generation` and they have `same parent or not`. If both given nodes have the `same parent`, the method `returns` that `parent`. Then, the method traverses up the tree from `node1` to find the `deepest common parent` with node2. It does this by repeatedly assigning node1 to its parent and checking if node1 is equal to node2. If node1 is equal to node2, it returns node1 as it's deepest common parent. If no common ancestor is found while traversing up from node1, the method then traverses up the tree from node2 to find the `deepest common parent` with node1. It does this by repeatedly assigning node2 to its parent and checking if node1 is equal to node2. If node1 is equal to node2, it returns node2 as it is the deepest common parent. If still no common deepest parent is found, the method returns node1 as a base case. The time complexity of the given code is `O(h)`, where h is the height of the tree. This is because the code traverses up the tree from each input node until it reaches the root or finds the deepest common parent. The space complexity of the given code is `O(1)` because it uses a constant amount of extra memory.

#### `(Q2)`
We try entering many different types of trees, such as

(i) This is a normal tree of type Integer with 1 as its Root Node. It has a left child 2 and a right child 3. The left child 2 has a left child 6 and a right child 7. The right child has a left child 4 and a right child 5. In the code this tree is named as tree1 with nodes named with letter b. Here is the image of how the tree looks like.

<img src="https://user-images.githubusercontent.com/91961949/233535677-0e40786f-ddba-436f-8ed2-d9a0fb66d526.jpg"  width="250" height="150">

(ii) This is a normal tree of type Integer with 8 as its Root Node. It has a left child 2 and a right child 10. The left child 2 has a left child 4 and a right child 6. The right child of 2 has a left child 4 and a right child 7.The right child of 10 has a left child 13. In the code this tree is named as tree2 with nodes named with letter o. Here is the image of how the tree looks like.

<img src="https://user-images.githubusercontent.com/91961949/233644101-63834e7b-e052-49ec-8c02-3a7541080069.jpg"  width="250" height="150">

(iii) This is a normal tree of type Integer with 11 as its Root Node. It has a left child 2 and a right child 14. The left child 2 has a right child 7. The right child 7 has a left child 5 and a right child 8. The right child 8 has a left child 6 and a right child 9. In the code this tree is named as tree3 with nodes named with letter s. Here is the image of how the tree looks like.

<img src="https://user-images.githubusercontent.com/91961949/233644104-4e3278d4-4f73-4eaf-bf78-b4a43af83438.jpg"  width="250" height="150">

(iv) This is a skew right tree of type Integer with 0 as its Root Node. It has only right child 1. Then again a right child of 1 is 2. Then again a right child of 2 is 3. Then again a right child of 3 is 4. In the code this tree is named as tree4 with nodes named with letter e. Here is the image of how the tree looks like.

<img src="https://user-images.githubusercontent.com/91961949/233644105-e04e94f4-0399-42de-81b1-4ed258477aa7.jpg"  width="250" height="150">

 (v) This is a Character Tree. We tried adding characters in it. With C at it's root node. Then left child of C is A. Then left child of A is T. Then left child of T is S. The right child of C is O. O has a left child with value B and a right child with value W. The W child has a right child S. In the code this tree is named as tree5 with nodes named with letter r.

<img src="https://user-images.githubusercontent.com/91961949/233644099-48afbfdf-19ac-4486-980c-55456d94c2e7.jpg"  width="250" height="150">

 (vi) This is a Sum Tree of type Integer with 8 as its Root Node. It has a left child 5 and a right child 3. Here sum of both left and right child that is 5 and 3 is equal to root node 8. The left child 5 has a left child 4 and a right child 1. Here sum of both left and right child that is 4 and 1 is equal to root node 5. The right child 3 has a left child 2 and a right child 1. Here sum of both left and right child that is 2 and 1 is equal to root node 3. As the main tree, left subTree and right subTree are also a sum tree this is a sum tree. Here is the image of how the tree looks like.

<img src="https://user-images.githubusercontent.com/91961949/233856652-5f77993e-5709-45fd-b469-8a2048e6ba9d.jpg"  width="250" height="150">

## `Q3`
#### InOrder Traversal
This is a recusive implementation of the Inorder Traversal. It will visit every node once in a specific order which is Left node -> Root node -> Right node for entire tree. If a left or Right child itself is a another tree then it will follow the same proccess there. Firstly, the tree traverses Left ways by recursively calling itself to the leftchild. Once it reaches the left most child. It compiles the next command which is To print Node's Value and then check if it has a right child. if it does it calls itself on the right child until we reach the right most child and follow the same procedure. At the end It will print out the inOrder Traversal of the given tree. The time complexity of the inOrder() method is O(n), where n is the number of nodes in the binary tree, because it visits each node of the tree exactly once.

#### PreOrder Traversal
This is a recusive implementation of the `PreOrder Traversal`. It will visit every node once in a specific order which is `Root node-> Left node-> Right node` for entire tree. If a left or Right child itself is a another tree then it will follow the same proccess there. Firstly, the tree prints it's Root and then it goes to left child and prints the value of it again. It will do so until it reaches the left most node. Then it will start going to Right node and prints accordingly. At the end It will print out the PreOrder Traversal of the given tree. The time complexity of this code is `O(n)`, where n is the number of nodes in the binary tree. This is because the method visits every node in the tree only once.

#### postOrder Traversal
This is a recusive implementation of the `postOrder Traversal`. It will visit every node once in a specific order which is `Left node-> Right node-> Root node` for entire tree. If a left or Right child itself is a another tree then it will follow the same proccess there. Firstly, the tree traverses Left ways by recursively calling itself to the leftchild. Once it reaches the left most child. It compiles the next command which is to go to right most of the left most. The time complexity of this code is `O(n)`, where n is the number of nodes in the binary tree. This is because the method visits every node in the tree only once.

## `Q4`

#### `InOrder Traversal (Efficient)`
This is implementation of InOrder traversal in `O(1) space` and `O(n) time`. To acheive that time complexity i used a `Stack`. As we are advised not to import any data structure but rather implement them ourselves, `I implemented a Stack` using a linkedlist. For the Inorder method, I first have the condition in the While loop and it checks if stack is not empty or Temporary node is not null. Then inside the loops it pushes the current node to the stack and then goes to the left node. Then enters the loop again and pushes the left node of root and then again goes left and enters loop again. This continues until we reach the leftmost node. Once it is achieved we pop the stack once and then print the value and check if there is anything to right of that node and if there is then push that in and check its left. At the end it will have printed the InOrder Solution.

## `Q5`
This is implementation of `Sum Tree` method for a Integer binary tree. A sum tree is a binary tree where the value of each node is equal to the sum of the values of its left and right children. The method `sumTree` takes a TreeNode<Integer> node as an argument, representing the root of a binary tree. It first checks if the `node is null` or if it has `no children`. If either condition is true, it `returns true`, as an `empty tree is considered a sum tree (By assumption)`. If the node has children, temporary variables `SumofLeft and SumofRight` are initialized to hold the sum of the left and right child nodes, respectively. If a child node is null, its sum is considered to be zero. Then, the code checks if the `value of the root node is equal to the sum of its left and right children`. If that is true, the method then `checks recursively` if both the left and right subtrees of the root are also sum trees. If `both subtrees are sum trees`, the method returns true, indicating that the binary tree is a sum tree. Otherwise, it returns false.
